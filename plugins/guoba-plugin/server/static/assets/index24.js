import{r as ref,bk as tryOnUnmounted,y as unref,d as defineComponent,M as Button,C as computed,L as watchEffect,a9 as useI18n,ak as isFunction,b as _export_sfc,c as resolveComponent,o as openBlock,h as createBlock,i as withCtx,k as createTextVNode,m as toDisplayString,D as mergeProps,E as useDesign,a$ as createSlots,f as renderList,aq as renderSlot,a0 as normalizeProps,a1 as guardReactiveProps,j as createVNode,bi as withInstall}from"./index.js";import{u as useRuleFormItem}from"./useFormItem.js";const countButton=_export_sfc(defineComponent({name:"CountButton",components:{Button:Button},props:{value:{type:[Object,Number,String,Array]},count:{type:Number,default:60},beforeStartFunc:{type:Function,default:null}},setup(props2){const loading=ref(!1),{currentCount:currentCount,isStart:isStart,start:start,reset:reset}=function(count){const currentCount=ref(count),isStart=ref(!1);let timerId;function clear(){timerId&&window.clearInterval(timerId)}function stop(){isStart.value=!1,clear(),timerId=null}function start(){unref(isStart)||timerId||(isStart.value=!0,timerId=setInterval((()=>{1===unref(currentCount)?(stop(),currentCount.value=count):currentCount.value-=1}),1e3))}function reset(){currentCount.value=count,stop()}return tryOnUnmounted((()=>{reset()})),{start:start,reset:reset,restart:function(){reset(),start()},clear:clear,stop:stop,currentCount:currentCount,isStart:isStart}}(props2.count),{t:t}=useI18n(),getButtonText=computed((()=>unref(isStart)?t("component.countdown.sendText",[unref(currentCount)]):t("component.countdown.normalText")));return watchEffect((()=>{void 0===props2.value&&reset()})),{handleStart:function(){return __this=this,__arguments=null,generator=function*(){const{beforeStartFunc:beforeStartFunc}=props2;if(beforeStartFunc&&isFunction(beforeStartFunc)){loading.value=!0;try{(yield beforeStartFunc())&&start()}finally{loading.value=!1}}else start()},new Promise(((resolve,reject)=>{var fulfilled=value=>{try{step(generator.next(value))}catch(e){reject(e)}},rejected=value=>{try{step(generator.throw(value))}catch(e){reject(e)}},step=x=>x.done?resolve(x.value):Promise.resolve(x.value).then(fulfilled,rejected);step((generator=generator.apply(__this,__arguments)).next())}));var __this,__arguments,generator},currentCount:currentCount,loading:loading,getButtonText:getButtonText,isStart:isStart}}}),[["render",function(_ctx,_cache,$props,$setup,$data,$options){const _component_Button=resolveComponent("Button");return openBlock(),createBlock(_component_Button,mergeProps(_ctx.$attrs,{disabled:_ctx.isStart,onClick:_ctx.handleStart,loading:_ctx.loading}),{default:withCtx((()=>[createTextVNode(toDisplayString(_ctx.getButtonText),1)])),_:1},16,["disabled","onClick","loading"])}]]);const CountdownInput=withInstall(_export_sfc(defineComponent({name:"CountDownInput",components:{CountButton:countButton},inheritAttrs:!1,props:{value:{type:String},size:{type:String,validator:v=>["default","large","small"].includes(v)},count:{type:Number,default:60},sendCodeApi:{type:Function,default:null}},setup(props2){const{prefixCls:prefixCls}=useDesign("countdown-input"),[state]=useRuleFormItem(props2);return{prefixCls:prefixCls,state:state}}}),[["render",function(_ctx,_cache,$props,$setup,$data,$options){const _component_CountButton=resolveComponent("CountButton"),_component_a_input=resolveComponent("a-input");return openBlock(),createBlock(_component_a_input,mergeProps(_ctx.$attrs,{class:_ctx.prefixCls,size:_ctx.size,value:_ctx.state}),createSlots({addonAfter:withCtx((()=>[createVNode(_component_CountButton,{size:_ctx.size,count:_ctx.count,value:_ctx.state,beforeStartFunc:_ctx.sendCodeApi},null,8,["size","count","value","beforeStartFunc"])])),_:2},[renderList(Object.keys(_ctx.$slots).filter((k=>"addonAfter"!==k)),(item=>({name:item,fn:withCtx((data=>[renderSlot(_ctx.$slots,item,normalizeProps(guardReactiveProps(data||{})))]))})))]),1040,["class","size","value"])}]]));withInstall(countButton);export{CountdownInput as C};
